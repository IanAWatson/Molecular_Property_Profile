"""Plot one or more collections of molecule information.

Consumes proto files generated by generate_profile.
Specify two or more such files on the command line.
A minimal usage might be

plot_collections.py CHEMBL_w_natoms.dat PUBCHEM_w_natoms.dat

which generates a plot containing the natoms distributions
for CHEMBL and PUBCHEM, previous computed.

Display will be to the screen. If the --stem option is specified
a png file will be created instead.
"""

from dataclasses import dataclass
import sys
from typing import List, Tuple

from absl import app
from absl import flags
from absl import logging

from google.protobuf import text_format

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure

import numpy as np
import pandas as pd

import collection_pb2

FLAGS = flags.FLAGS

flags.DEFINE_list("collection", [], "list of collections to plot (stems from generate_profile)")
flags.DEFINE_string("feature_description", "", "File containing feature descriptions")
flags.DEFINE_string("stem", "", "name stem for .png files")
flags.DEFINE_float('X', 0.0, "Figure size (X) for .png output")
flags.DEFINE_float('Y', 0.0, "Figure size (Y) for .png output")
flags.DEFINE_float('xmin', -1.0, "manually set lower limit")
flags.DEFINE_float('xmax', -1.0, "manually set upper limit")
flags.DEFINE_float('width', 0.0, 'Width of bars in bar plots')
flags.DEFINE_float('quantile', 0.0, 'Truncate plots to the <quantile> quantile')
flags.DEFINE_boolean('verbose', False, "verbose output")

@dataclass
class Options:
    verbose: bool = False

    # The file name of plots generated
    stem: str = ""

    # Plot dimensions in inches. Both must be set in order
    # to have any effect
    x: int = 0
    y: int = 0;

    # Manually specify the x range of the plot
    xmin: float = 0.0
    xmax: float = 0.0

    # For bar plots, manually set the width
    width: int = 0

    # Truncate plots to a given quantile
    quantile: float = 0.0

def usage(ret):
  sys.exit(ret)

def shrink_to_quantile(quantile: float,
                       x: np.array,
                       counts: List[np.array]) -> Tuple[np.array, List[np.array]]:
  """Reduce `x` and `counts` to the `quantile` quantile.

  'x' holds the x axis for plotting. `counts` holds a list of frequency values
  all aligned with `x`.
  Args:
  Returns:
    Updated values for x and counts
  """
  # If this looks like a fractional property do not scale
  # hmmm, not sure...
  # if x[-1] == 1.0:
  #   return (x, counts)

  npoints = len(x)
  totals = np.zeros(npoints)
  nobs = 0
  for c in counts:
    totals = np.add(totals, c)
    nobs += np.sum(c)

  points_needed = int(round(nobs * quantile))

  left = 0
  for i,tot in enumerate(totals):
    if tot >= points_needed:
      left = i
      break

  right = len(totals)
  sum = 0
  for i in range(len(totals)):
    j = len(totals) - i - 1
    sum += totals[j]
    if sum >= points_needed:
      right = j
      break

  if left == 0 and right == npoints - 1:
    return (x, counts)
  
  print(f"npoints {npoints} left {left} right {right}")
  newx = x[left:right + 1]
  new_npoints = right - left + 1
  new_counts = []
  for c in counts:
    new_counts.append(c[left:right + 1])

  return (newx, new_counts)

def get_width(protos: List[collection_pb2.Descriptor],
               options: Options) -> float:
   """Return the width to be used for bar plots.

   Args:
   Returns:
   """
   if options.width > 0:
     return options.width

   return 0.9 * 1.0 / len(protos)

def make_legend(proto: collection_pb2.Descriptor) -> str:
  """Generate a legend for the feature in `proto`

  Args:
    proto:
  Returns:
    A lagend string
  """
  if proto.maxval <= 1.0:
    return f"{proto.description.source} {proto.mean:.3f}"
  elif proto.maxval <= 10.0:
    return f"{proto.description.source} {proto.mean:.2f}"
  elif proto.maxval <= 100.0:
    return f"{proto.description.source} {proto.mean:.1f}"
  elif proto.mean <= 1000.0:
    return f"{proto.description.source} {proto.mean:.0f}"
  else:
    return f"{proto.description.source} {proto.mean}"

def get_range(protos: List[collection_pb2.Descriptor]) -> Tuple:
  """Determine overall min and max of `protos`

  Args:
    protos: list of
  Returns:
  """

  # Get the range of the graph
  min_value = protos[0].minval
  max_value = protos[0].maxval
  for i in range(1, len(protos)):
    min_value = min(protos[i].minval, min_value)
    max_value = max(protos[i].maxval, max_value)
  logging.info("Range of %s btw %f and %f", protos[0].description.feature_name, min_value, max_value)
  return (min_value, max_value)

def int_plot(options: Options,
             protos: List,
             carray: List[np.array],
             varray: List[np.array]) -> None:
  """Generate a plot of integer data

  Args:
    options: options controlling behaviour
    protos: Descriptor protos
    carray: List of arrays of values extracted from `protos`
    varray: List of arrays of counts extracted from `protos`
  """
  (min_value, max_value) = get_range(protos)

  nvalues = round(max_value - min_value) + 1
  logging.info("Range %r to %r needs %d values", min_value, max_value, nvalues)

  # Each set will be aligned with this as the X axis
  x = np.arange(round(min_value), round(max_value) + 1)
  # A count array for each proto
  counts = []
  for proto in protos:
    c = np.zeros(nvalues)
    for vc in proto.int_values:
      ndx = round(vc.value - min_value)
      c[ndx] = vc.count
    counts.append(c)

  if options.quantile > 0.0:
    (x, counts) = shrink_to_quantile(options.quantile, x, counts)

  bars  = []
  width = get_width(protos, options)
  for (i, c) in enumerate(counts):
    normed = c / np.linalg.norm(c, ord=1)
    b = plt.bar(x + width * i, normed, width,  color=protos[i].description.line_color)
#   b.set_label(protos[i].description.source)
    b.set_label(make_legend(protos[i]))
    bars.append(b)

  ymax = plt.gca().get_ylim()[1]
  for proto in protos:
    mean = proto.mean
    x = [mean, mean]
    y = [0.95 * ymax, 0.99 * ymax]
    plt.plot(x, y, color=proto.description.line_color)

  if options.xmin >= 0.0 and options.xmax > options.xmin:
    plt.xlim(options.xmin, options.xmax)
  plt.xlabel(protos[0].description.feature_name)
  plt.title(protos[0].description.description)
  plt.ylabel("Prevalence")
  plt.legend()
  if len(options.stem) == 0:
    plt.show()
    plt.close()
    return

  # generating png.
  fname = f"{options.stem}_{protos[0].description.feature_name}.png"

  fig = plt.gcf()
  if options.x > 0.0 and options.y >= 0.0:
    fig.set_size_inches(options.x, options.y)
  fig.savefig(fname, dpi=200)

  plt.close()


def float_plot(options: Options,
               protos: List,
               carray: List[np.array],
               varray: List[np.array]) -> None:
  """Generate a plot of float data

  Args:
    options: options controlling behaviour
    protos: Descriptor protos
    carray: List of arrays of values extracted from `protos`
    varray: List of arrays of counts extracted from `protos`
  """
  (min_value, max_value) = get_range(protos)
  logging.info("Range %r to %r", min_value, max_value)

  # Each set will be aligned with this as the X axis
  dx = (max_value - min_value) / 50.0
  x = np.arange(min_value, max_value + dx, dx)
  nvalues = len(x)
  counts = []
  df = pd.DataFrame()
  for proto in protos:
    c = np.zeros(nvalues)
    for vc in proto.float_values:
      ndx = round((vc.value - min_value) / dx)
      c[ndx] = vc.count
    counts.append(c)

  plts  = []

  for (i, c) in enumerate(counts):
    normed = c / np.linalg.norm(c, ord=1)
    p = plt.plot(x, normed, color=protos[i].description.line_color,
                 label=make_legend(protos[i]),
                 linewidth = 2 if i == 0 else 1)
    plts.append(p)

  ymax = plt.gca().get_ylim()[1]
  for proto in protos:
    mean = proto.mean
    x = [mean, mean]
    y = [0.0, 0.04 * ymax]
    plt.plot(x, y, color=proto.description.line_color)

  if options.xmin >= 0.0 and options.xmax > options.xmin:
    plt.xlim(options.xmin, options.xmax)
  plt.xlabel(protos[0].description.feature_name)
  plt.title(protos[0].description.description)
  plt.ylabel("Prevalence")
  plt.legend()
  if len(options.stem) == 0:
    plt.show()
    plt.close()
    return

  # generating png
  fname = f"{options.stem}_{protos[0].description.feature_name}.png"

  fig = plt.gcf()
  if options.x > 0.0 and options.y >= 0.0:
    fig.set_size_inches(options.x, options.y)
  fig.savefig(fname, dpi=200)
  plt.close()

def value_counts_to_arrays(from_proto) -> List[np.array]:
  """Convert the Int/Float ValueCount data `from_proto` to np arrays.

  Args:
    from_proto: source of data. Will be either IntValueCount or FloatValueCount
  Returns
    Two np arrays, one with the values, the other with counts.
  """
  n = len(from_proto)
  value = np.zeros(n)
  count = np.zeros(n)
  for i in range(n):
    vc = from_proto[i]
    value[i] = vc.value
    count[i] = vc.count

  return (value, count)

def do_plots(options: Options,
             protos:List) -> None:
  """Generate property profile plots from `protos`.

  Args:
    options:
    protos:
    name_stem:
  Returns:
  """
  varray:List[np.array] = []
  carray:List[np.array] = []
  is_int = 0
  for proto in protos:
    if len(proto.int_values) > 0:
      (value, count) = value_counts_to_arrays(proto.int_values)
      is_int += 1
    else:
      (value, count) = value_counts_to_arrays(proto.float_values)
    varray.append(value)
    carray.append(count)

  if is_int > 0:
    return int_plot(options, protos, varray, carray)
  else:
    return float_plot(options, protos, varray, carray)

def process_group_of_files(options: Options,
                           collections:List[str],
                           feature_name: str,
                           feature_description: str):
  """Generate a plot for `feature` across `collections`.

  Relies on a standardised naming scheme for the proto files,
  <collection>_<feature>.dat

  Args:
    options: controls options
    collections: list of collections - actually the stem from generate_profile
    feature_name: the feature to plot
    feature_description: an understandable description of `feature`.
  Returns:
  """
  protos = []
  for collection in collections:
    fname = f"{collection}_{feature_name}.dat"
    with open(fname, "r") as reader:
      file_contents = reader.readlines()

    proto = text_format.Parse('\n'.join(file_contents), collection_pb2.Descriptor())
    if feature_name != proto.description.feature_name:
      raise f"Feature mismatch in #{fname}, should be {feature}"
    protos.append(proto)

  if options.verbose:
    logging.info("Read %d protos for feature %s\n", len(protos), feature_name)

  do_plots(options, protos)

def process_files_from_cmdline(options: Options,
                                args: List[str]):
  """Plotting a single feature, in the files in `args`.

  Args:
    options: Options controlling output.
    args: List of files from the command line.
  """
  protos = []
  feature_name = ""
  for i in range(1, len(args)):
    fname = args[i]
    with open(fname, 'r') as reader:
      contents = reader.readlines()

    if len(contents) == 0:
      logging.fatal("No data in %s", fname)

    proto = text_format.Parse('\n'.join(contents), collection_pb2.Descriptor())
    protos.append(proto)

    if feature_name == "":
      feature_name = proto.description.feature_name
    elif feature_name != proto.description.feature_name:
      logging.fatal("Name mismatch %s vs %s", feature_name, proto.feature_name)

  if options.verbose:
    logging.info("Read %d protos for feature %s\n", len(protos), feature_name)

  do_plots(options, protos)

def plot_profiles(args):
  """Generate plots for the protos in `args`.
  """
  options = Options()
  options.verbose = FLAGS.verbose
  options.stem = FLAGS.stem
  options.x = FLAGS.X
  options.y = FLAGS.Y
  options.xmin = FLAGS.xmin
  options.xmax = FLAGS.xmax
  options.width = FLAGS.width
  options.quantile = FLAGS.quantile

  # There are two ways in which we can make plots.
  # Files on the command line, plotting one feature.
  # Or, via the --collection and --feature_description options
  # which specify a set of features to plot.
  if len(FLAGS.collection) > 0 and len(FLAGS.feature_description) > 0:
    with open(FLAGS.feature_description, 'r') as reader:
      file_contents = reader.read()
    feature_descriptions = text_format.Parse(file_contents, collection_pb2.Descriptions())
    for feature in feature_descriptions.feature_to_description:
      process_group_of_files(options, FLAGS.collection, feature,
                             feature_descriptions.feature_to_description[feature])
  else:
    if len(args) < 3:
      logging.error("Must specify at least two protos to plot")
      usage(1)
    process_files_from_cmdline(options, args)


if __name__ == "__main__":
  app.run(plot_profiles)
